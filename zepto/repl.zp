; A small REPL for zepto in zepto
(load "readline/readline")
(import-all "readline" "rl")

(define *prompt* "zepto> ")
(define *ret* "=> ")
(define *conf* (++ (get-home-dir) "/.zeptorc"))
(define *histfile* (++ (get-home-dir) "/.zepto_history"))
(define *env* *global-env*)

(define (do-exit args)
  (begin
    (write "Moriturus te saluto!")
    (exit (if (null? args) 0 (string->number (car args))))))

(define (set-prompt args)
  (if (not (null? args))
    (begin
     (set! *prompt* (car args))
     (repl))))

(define meta-commands
  (make-hash
    ":q" do-exit
    ":quit" do-exit
    ":p" set-prompt
    ":prompt" set-prompt))

(define (write-hist-item item) "Unbuffered writing, just to make sure nothing's lost"
  (let* ((cont (read-contents *histfile*))
         (hist-to (open-output-file *histfile*)))
    (begin
      (rl:add-history item)
      (write (substring cont 0 (sub1 (length cont))) hist-to)
      (write item hist-to)
      (close-output-file hist-to))))

(define (repl)
  (begin
    (define input (rl:readline *prompt*))
    (if (falsy? input)
      (repl))
    (write-hist-item input)
    (define res (catch-vm-error (string:parse input) *env*))
    (let* ((split (string:split (->string res) #\=))
           (cmd (car split)))
      (if (not (nil? (meta-commands cmd)))
        ((meta-commands cmd) (cdr split))
        (begin
          (display *ret*)
          (write res)
          (repl))))))

(if (not (eq? (open-input-file *conf*) #f))
  (load *conf*))

(let ((x (open-input-file *histfile*)))
  (if (not (eq? x #f))
    (begin
      (map rl:add-history (string:split (read-contents *histfile*) #\newline))
      (close-input-file x))))

(write (eval '(load "module.zp") *env*))

(repl)
