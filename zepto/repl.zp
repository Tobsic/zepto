; A small REPL for zepto in zepto
(load "readline")
(import-all "readline" "rl")

(define *prompt* "zepto> ")
(define *input-highlight* :reset)
(define *output-highlight* :reset)
(define *ret* "=> ")
(define *statement-count* 1)
(define *conf* (++ (get-home-dir) "/.zeptorc"))
(define *histfile* (++ (get-home-dir) "/.zepto_history"))
(define *env* *global-env*)
(define *header* (++ "zepto Version " zepto:version-str ", compiled with GHC version " zepto:ghc-str "
Copyright (C) 2016 Veit Heller (GPL)
This is free software; see the accompanying LICENSE for copying conditions.
There is NO warranty whatsoever.
Hail Eris, all rites reversed.

Type ':quit' or press Ctrl-C to exit interpreter,
':help' to get a list of commands or ':license' to get the license text"))

(define (write-plain arg)
  (begin
    (color :reset)
    (write arg)))

(define (error-plain . args)
  (begin
    (color :reset)
    (apply error args)))

(define (do-exit . args)
  (begin
    (write-plain "Moriturus te saluto!")
    (exit (if (null? args) 0 (string->number (car args))))))

(define (show-commands . args)
  (begin
    (map (lambda (x) (write-plain (++ (car x) ": " (->string (cadr x)))))
         (zepto:get-bindings (if (null? args) "" (car args)) *env*))
    (repl)))

(define (set-prompt . args)
  (if (not (null? args))
    (begin
     (set! *prompt* (string:join args))
     (repl))
    (begin
      (error-plain "option :p requires an argument (example: ':p=new-prompt>')")
      (repl))))

(define (show-license . args)
  (begin
    (write-plain (read-contents (++ (zepto:home) "assets/license_interactive.as")))
    (repl)))

(define (show-complete-license . args)
  (begin
    (write-plain (read-contents (++ (zepto:home) "assets/complete_license.as")))
    (repl)))

(define meta-commands
  (make-hash
    ":q" do-exit
    ":quit" do-exit
    ":p" set-prompt
    ":license" show-license
    ":complete-license" show-complete-license
    ":help" show-commands
    ":prompt" set-prompt))

(define (write-hist-item item) "Unbuffered writing, just to make sure nothing's lost"
  (let* ((cont (read-contents *histfile*))
         (hist-to (open-output-file *histfile*)))
    (begin
      (rl:add-history item)
      (write (substring cont 0 (sub1 (length cont))) hist-to)
      (write item hist-to)
      (close-output-file hist-to))))

(define (string:parseable? str) (not (in? (catch-vm-error `(string:parse ,str)) "Parse error at")))

(define (repl)
  (begin
    (define input (rl:readline (++ (if (function? *prompt*) (*prompt*) *prompt*)
                                   (color *input-highlight* #{:to-str #t}))))
    (if (falsy? input)
      (repl))
    (set! *statement-count* (add1 *statement-count*))
    (write-hist-item input)
    (if (string:parseable? input)
      (define res (catch-vm-error (macro-expand (string:parse input)) *env*))
      (define res (catch-vm-error `(string:parse ,input))))
    (let* ((split (string:split (->string res) #\=))
           (cmd (car split)))
      (if (not (nil? (meta-commands cmd)))
        (apply (meta-commands cmd) (cdr split))
        (begin
          (display (if (function? *ret*) (*ret*) *ret*))
          (color *output-highlight*)
          (write res)
          (repl))))))

(if (not (eq? (open-input-file *conf*) #f))
  (load *conf*))

(let ((x (open-input-file *histfile*)))
  (if (not (eq? x #f))
    (begin
      (reduce (lambda (_ el) (rl:add-history el)) #f (string:split (read-contents *histfile*) #\newline))
      (close-input-file x))))

(write *header*)

(write (eval '(load "module.zp") *env*))

(repl)
