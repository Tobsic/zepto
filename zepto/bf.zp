(define (bf str)
  (define overunder [lambda (x) (mod x 256)])
  (define t string:tail)
  (define (loop str prog n)
    (let ((x (internal (t str) [] (add1 n))))
      (if (and (list? x) (= (length x) 2) (string? (car x)))
        (list (car x)
          (+= prog (list 'let (string->symbol (++ "loop" (->string n))) '((dummy 0))
                     (++ (list 'begin) (cadr x)
                         (list
                           `(if (eq? (tape ptr) 0)
                             (nil)
                             (,(string->symbol (++ "loop" (->string n))) 0)))))))
          (begin (error "Mismatched brackets") (exit 1)))))
  (define (internal str prog n)
    (if (string:empty? str)
        prog
        (case (string:head str)
            ((#\>) (internal (t str) (+= prog [set! ptr (add1 ptr)]) n))
            ((#\<) (internal (t str) (+= prog [set! ptr (sub1 ptr)]) n))
            ((#\+) (internal (t str) (+= prog [vector:set! tape ptr (ou (add1 (tape ptr)))]) n))
            ((#\-) (internal (t str) (+= prog [vector:set! tape ptr (ou (sub1 (tape ptr)))]) n))
            ((#\.) (internal (t str) (+= prog [display (string (integer->char (tape ptr))) :flush]) n))
            ((#\,)
              (internal (t str)
                    (+= prog [vector:set! tape ptr (ou (read-char integer->char (tape ptr)))])
                    n))
            ((#\[) 
              (let ((evald (loop str prog n)))
                (internal (car evald) (cadr evald) n)))
            ((#\]) (list (t str) prog))
            (else (internal (t str) prog n)))))
  (list
    (+= (list 'let `((ou ,overunder) (tape (make-vector 30000 0)) (ptr 0)))
      (internal (string:join (cdr (string:split str #\newline)) #\newline)
                (list 'begin)
                0))))

(zepto:implements-lang bf "bf")
(zepto:implements-lang bf "brainfuck")
